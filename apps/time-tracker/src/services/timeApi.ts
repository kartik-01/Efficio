import { Category } from '../types';

// API base URL - injected by webpack DefinePlugin at build time
declare const process: {
  env: {
    API_BASE_URL?: string;
  };
};

const API_BASE_URL = process.env.API_BASE_URL || 'http://localhost:4000/api';

// Token getter function type - will be set by initializeTimeApi
let getAccessToken: (() => Promise<string | undefined>) | null = null;
let isInitialized = false;

// Initialize timeApi with Auth0 token getter
export const initializeTimeApi = (tokenGetter: () => Promise<string | undefined>) => {
  getAccessToken = tokenGetter;
  isInitialized = true;
};

// Check if timeApi is ready
export const isTimeApiReady = () => isInitialized && getAccessToken !== null;

// Helper function to get headers with authorization
const getHeaders = async (): Promise<HeadersInit> => {
  const headers: HeadersInit = {
    'Content-Type': 'application/json',
  };

  if (!getAccessToken) {
    console.error('getAccessToken function is not initialized - API calls will fail');
    throw new Error('Authentication not initialized. Please refresh the page.');
  }

  try {
    const token = await getAccessToken();
    if (token && token.trim()) {
      headers['Authorization'] = `Bearer ${token}`;
    } else {
      console.error('Token getter returned empty/undefined token');
      throw new Error('Failed to retrieve access token. Please login again.');
    }
  } catch (error) {
    console.error('Failed to get access token:', error);
    throw error;
  }

  return headers;
};

// Helper to handle API responses
const handleResponse = async <T>(response: Response): Promise<T> => {
  const result = await response.json().catch(() => ({}));
  
  if (!response.ok) {
    console.error('API Error Response:', {
      status: response.status,
      statusText: response.statusText,
      error: result
    });
    throw new Error(result.message || result.error || `API request failed: ${response.status}`);
  }

  // Extract data from response if it's wrapped
  const data = result.data !== undefined ? result.data : result;
  return data;
};

// Plan interface
export interface Plan {
  id: string;
  _id?: string;
  userId?: string;
  taskId?: string | null;
  taskTitle?: string | null;
  categoryId: string;
  startTime: string | Date;
  endTime: string | Date;
  status: 'scheduled' | 'in_progress' | 'done' | 'canceled';
  notes?: string;
  sessionId?: string;
  instanceDate?: string | Date;
  isAutoGenerated?: boolean;
  isOverridden?: boolean;
  templateStartTime?: string;
  templateEndTime?: string;
  createdAt?: string | Date;
  updatedAt?: string | Date;
}

export interface CreatePlanData {
  taskId?: string | null;
  taskTitle?: string | null;
  categoryId?: string;
  startTime: string; // ISO 8601 string
  endTime: string; // ISO 8601 string
  notes?: string;
  isOverride?: boolean; // For creating overrides for virtual plans
}

export interface UpdatePlanData {
  taskId?: string | null;
  taskTitle?: string | null;
  categoryId?: string;
  startTime?: string;
  endTime?: string;
  notes?: string;
  status?: 'scheduled' | 'in_progress' | 'done' | 'canceled';
  sessionId?: string;
}

// Plans API
export const plansApi = {
  // Get plans for a date range
  async getPlans(params: { date?: string; start?: string; end?: string; tz?: string; status?: string }): Promise<Plan[]> {
    const headers = await getHeaders();
    
    const queryParams = new URLSearchParams();
    if (params.date) queryParams.append('date', params.date);
    if (params.start) queryParams.append('start', params.start);
    if (params.end) queryParams.append('end', params.end);
    if (params.tz) queryParams.append('tz', params.tz);
    if (params.status) queryParams.append('status', params.status);
    
    const url = `${API_BASE_URL}/time/plans?${queryParams.toString()}`;
    const response = await fetch(url, { headers });
    
    const plans = await handleResponse<Plan[]>(response);
    
    // Normalize dates and ensure id field
    return plans.map(plan => ({
      ...plan,
      id: plan._id || plan.id || '',
      startTime: typeof plan.startTime === 'string' ? new Date(plan.startTime) : plan.startTime,
      endTime: typeof plan.endTime === 'string' ? new Date(plan.endTime) : plan.endTime,
      instanceDate: plan.instanceDate ? (typeof plan.instanceDate === 'string' ? new Date(plan.instanceDate) : plan.instanceDate) : undefined,
    }));
  },

  // Create a new plan
  async createPlan(data: CreatePlanData): Promise<Plan> {
    const headers = await getHeaders();
    
    const response = await fetch(`${API_BASE_URL}/time/plans`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data),
    });
    
    const plan = await handleResponse<Plan>(response);
    
    return {
      ...plan,
      id: plan._id || plan.id || '',
      startTime: typeof plan.startTime === 'string' ? new Date(plan.startTime) : plan.startTime,
      endTime: typeof plan.endTime === 'string' ? new Date(plan.endTime) : plan.endTime,
    };
  },

  // Update an existing plan
  async updatePlan(planId: string, data: UpdatePlanData): Promise<Plan> {
    const headers = await getHeaders();
    
    const response = await fetch(`${API_BASE_URL}/time/plans/${planId}`, {
      method: 'PATCH',
      headers,
      body: JSON.stringify(data),
    });
    
    const plan = await handleResponse<Plan>(response);
    
    return {
      ...plan,
      id: plan._id || plan.id || planId,
      startTime: typeof plan.startTime === 'string' ? new Date(plan.startTime) : plan.startTime,
      endTime: typeof plan.endTime === 'string' ? new Date(plan.endTime) : plan.endTime,
    };
  },

  // Delete a plan
  async deletePlan(planId: string): Promise<void> {
    const headers = await getHeaders();
    
    console.log('[plansApi.deletePlan] Deleting plan:', planId);
    console.log('[plansApi.deletePlan] URL:', `${API_BASE_URL}/time/plans/${planId}`);
    
    const response = await fetch(`${API_BASE_URL}/time/plans/${planId}`, {
      method: 'DELETE',
      headers,
    });
    
    console.log('[plansApi.deletePlan] Response status:', response.status);
    
    if (!response.ok) {
      const result = await response.json().catch(() => ({}));
      console.error('[plansApi.deletePlan] Error response:', result);
      throw new Error(result.message || result.error || `Failed to delete plan: ${response.status}`);
    }
    
    const result = await response.json().catch(() => ({}));
    console.log('[plansApi.deletePlan] Success:', result);
  },

  // Classify title to get category
  async classifyTitle(title: string): Promise<{ categoryId: string; confidence: number; source: string }> {
    const headers = await getHeaders();
    
    const response = await fetch(`${API_BASE_URL}/time/classify`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ title }),
    });
    
    return handleResponse<{ categoryId: string; confidence: number; source: string }>(response);
  },
};

// Session interface
export interface Session {
  id: string;
  _id?: string;
  userId?: string;
  taskId?: string | null;
  taskTitle?: string | null;
  categoryId: string;
  startTime: string | Date;
  endTime?: string | Date | null;
  duration?: number;
  notes?: string;
  source?: string;
}

export interface CreateSessionData {
  taskId?: string | null;
  taskTitle?: string | null;
  categoryId: string;
  startTime?: string; // ISO 8601 string
  endTime?: string; // ISO 8601 string
  notes?: string;
}

// Sessions API
export const sessionsApi = {
  // Get running session
  async getRunning(): Promise<Session | null> {
    const headers = await getHeaders();
    const response = await fetch(`${API_BASE_URL}/time/sessions/running`, { headers });
    
    if (response.status === 404) {
      return null; // No running session
    }
    
    const session = await handleResponse<Session>(response);
    return {
      ...session,
      id: session._id || session.id || '',
      startTime: typeof session.startTime === 'string' ? new Date(session.startTime) : session.startTime,
      endTime: session.endTime ? (typeof session.endTime === 'string' ? new Date(session.endTime) : session.endTime) : null,
    };
  },

  // Start a new session
  async startSession(data: { taskId?: string | null; taskTitle?: string | null; categoryId: string; notes?: string }): Promise<Session> {
    const headers = await getHeaders();
    const response = await fetch(`${API_BASE_URL}/time/sessions/start`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data),
    });
    
    const session = await handleResponse<Session>(response);
    return {
      ...session,
      id: session._id || session.id || '',
      startTime: typeof session.startTime === 'string' ? new Date(session.startTime) : session.startTime,
      endTime: session.endTime ? (typeof session.endTime === 'string' ? new Date(session.endTime) : session.endTime) : null,
    };
  },

  // Stop a running session
  async stopSession(sessionId: string, endTime?: string): Promise<Session> {
    const headers = await getHeaders();
    const response = await fetch(`${API_BASE_URL}/time/sessions/${sessionId}/stop`, {
      method: 'POST',
      headers,
      body: JSON.stringify({ endTime }),
    });
    
    const session = await handleResponse<Session>(response);
    return {
      ...session,
      id: session._id || session.id || sessionId,
      startTime: typeof session.startTime === 'string' ? new Date(session.startTime) : session.startTime,
      endTime: session.endTime ? (typeof session.endTime === 'string' ? new Date(session.endTime) : session.endTime) : null,
    };
  },

  // Create a manual session
  async createSession(data: CreateSessionData): Promise<Session> {
    const headers = await getHeaders();
    const response = await fetch(`${API_BASE_URL}/time/sessions`, {
      method: 'POST',
      headers,
      body: JSON.stringify(data),
    });
    
    const session = await handleResponse<Session>(response);
    return {
      ...session,
      id: session._id || session.id || '',
      startTime: typeof session.startTime === 'string' ? new Date(session.startTime) : session.startTime,
      endTime: session.endTime ? (typeof session.endTime === 'string' ? new Date(session.endTime) : session.endTime) : null,
    };
  },

  // List sessions
  async listSessions(params: { date?: string; tz?: string }): Promise<Session[]> {
    const headers = await getHeaders();
    
    const queryParams = new URLSearchParams();
    if (params.date) queryParams.append('date', params.date);
    if (params.tz) queryParams.append('tz', params.tz);
    
    const url = `${API_BASE_URL}/time/sessions?${queryParams.toString()}`;
    const response = await fetch(url, { headers });
    
    const sessions = await handleResponse<Session[]>(response);
    return sessions.map(session => ({
      ...session,
      id: session._id || session.id || '',
      startTime: typeof session.startTime === 'string' ? new Date(session.startTime) : session.startTime,
      endTime: session.endTime ? (typeof session.endTime === 'string' ? new Date(session.endTime) : session.endTime) : null,
    }));
  },

  // Update a session
  async updateSession(sessionId: string, data: Partial<CreateSessionData & { startTime?: string; endTime?: string }>): Promise<Session> {
    const headers = await getHeaders();
    
    const response = await fetch(`${API_BASE_URL}/time/sessions/${sessionId}`, {
      method: 'PATCH',
      headers,
      body: JSON.stringify(data),
    });
    
    const session = await handleResponse<Session>(response);
    return {
      ...session,
      id: session._id || session.id || sessionId,
      startTime: typeof session.startTime === 'string' ? new Date(session.startTime) : session.startTime,
      endTime: session.endTime ? (typeof session.endTime === 'string' ? new Date(session.endTime) : session.endTime) : null,
    };
  },

  // Delete a session
  async deleteSession(sessionId: string): Promise<void> {
    const headers = await getHeaders();
    
    const response = await fetch(`${API_BASE_URL}/time/sessions/${sessionId}`, {
      method: 'DELETE',
      headers,
    });
    
    if (!response.ok) {
      const result = await response.json().catch(() => ({}));
      throw new Error(result.message || result.error || `Failed to delete session: ${response.status}`);
    }
  },
};

// Summary API
export const timeApi = {
  // Get summary for a time range
  async getSummary(params: { range?: string; tz?: string }): Promise<{ success: boolean; data: any }> {
    const headers = await getHeaders();
    
    const queryParams = new URLSearchParams();
    if (params.range) queryParams.append('range', params.range);
    if (params.tz) queryParams.append('tz', params.tz);
    
    const url = `${API_BASE_URL}/time/summary?${queryParams.toString()}`;
    const response = await fetch(url, { headers });
    
    return handleResponse<{ success: boolean; data: any }>(response);
  },

  // Get daily summary for a specific date
  async getDailySummary(date: string, tz?: string): Promise<{ success: boolean; data: any }> {
    const headers = await getHeaders();
    
    const queryParams = new URLSearchParams();
    queryParams.append('date', date);
    if (tz) queryParams.append('tz', tz);
    
    const url = `${API_BASE_URL}/time/summary/daily?${queryParams.toString()}`;
    const response = await fetch(url, { headers });
    
    return handleResponse<{ success: boolean; data: any }>(response);
  },
};

