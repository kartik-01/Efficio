import { useState, useEffect, useMemo } from 'react';
import { PlannedBlock, Category } from '../types';
import { formatTime, getCategoryColor } from '../lib/utils';
import { classifyTitleToCategoryId } from '../lib/classification';
import { Button, Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, Input, Label, SYSTEM_CATEGORIES } from '@efficio/ui';
import { Play, Check, Calendar, Plus, Trash2, Square, Edit } from 'lucide-react';
import { plansApi, sessionsApi, isTimeApiReady, Plan } from '../services/timeApi';
import { useTasksStore } from '../store/slices/tasksSlice';
import { usePlansStore } from '../store/slices/plansSlice';
import { useSessionsStore } from '../store/slices/sessionsSlice';
import { useSummaryStore } from '../store/slices/summarySlice';
import { toast } from 'sonner';

const HOURS = Array.from({ length: 24 }, (_, i) => i);

interface PlannedTimeBlocksProps {
  selectedDate: Date;
  getAccessToken?: () => Promise<string | undefined>;
}

export function PlannedTimeBlocks({ selectedDate, getAccessToken }: PlannedTimeBlocksProps) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [editingBlock, setEditingBlock] = useState<PlannedBlock | null>(null);
  const [selectedHour, setSelectedHour] = useState<number | null>(null);
  const [newBlock, setNewBlock] = useState({
    title: '',
    startTime: '',
    endTime: '',
  });

  // Zustand stores
  const { tasks } = useTasksStore();
  const { plans: realPlans, loading, fetchPlans, createPlan, updatePlan, deletePlan } = usePlansStore();
  const { activeSession, startSession, stopSession, fetchActiveSession } = useSessionsStore();
  const { fetchSummary } = useSummaryStore();

  const dateStr = useMemo(() => {
    const year = selectedDate.getFullYear();
    const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
    const day = String(selectedDate.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }, [selectedDate]);

  const normalizeDateToString = (date: Date | string): string => {
    const d = typeof date === 'string' ? new Date(date) : date;
    d.setHours(0, 0, 0, 0);
    return d.toISOString().split('T')[0];
  };

  const findOverrideForTaskAndDate = (
    taskId: string,
    targetDate: Date,
    plans: Plan[],
    includeCanceled: boolean = false
  ): Plan | undefined => {
    const targetDateStr = normalizeDateToString(targetDate);
    const searchTaskId = String(taskId);
    
    return plans.find(p => {
      if (!p.taskId || p.isAutoGenerated) return false;
      if (!includeCanceled && p.status === 'canceled') return false;
      if (includeCanceled && p.status !== 'canceled') return false;
      
      let pTaskId: string;
      if (typeof p.taskId === 'string') {
        pTaskId = p.taskId;
      } else if (p.taskId && typeof (p.taskId as any).toString === 'function') {
        pTaskId = (p.taskId as any).toString();
      } else {
        pTaskId = String(p.taskId);
      }
      
      if (pTaskId !== searchTaskId) return false;
      
      if (p.instanceDate) {
        const pDateStr = normalizeDateToString(p.instanceDate);
        return pDateStr === targetDateStr;
      }
      
      const pStartDateStr = normalizeDateToString(p.startTime);
      return pStartDateStr === targetDateStr;
    });
  };

  useEffect(() => {
    if (!isTimeApiReady()) return;
    
    const year = selectedDate.getFullYear();
    const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
    const day = String(selectedDate.getDate()).padStart(2, '0');
    const dateStr = `${year}-${month}-${day}`;
    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    
    fetchPlans(dateStr, tz);
  }, [selectedDate, fetchPlans]);

  const mergedBlocks = useMemo(() => {
    const virtualBlocks: PlannedBlock[] = [];
    const realBlocks: PlannedBlock[] = [];

    // Convert realPlans to PlannedBlock format
    const targetDateStr = normalizeDateToString(selectedDate);
    realPlans.forEach(plan => {
      // Check if plan matches the selected date
      let planDateStr: string;
      if (plan.instanceDate) {
        planDateStr = normalizeDateToString(plan.instanceDate);
      } else {
        planDateStr = normalizeDateToString(plan.startTime);
      }

      if (planDateStr !== targetDateStr) return;
      
      // Skip canceled plans unless they're overrides
      if (plan.status === 'canceled' && !plan.isOverridden) return;

      // Convert categoryId to Category
      const categoryId = plan.categoryId || 'work';
      // Capitalize first letter to match SYSTEM_CATEGORIES format
      const categoryName = categoryId.charAt(0).toUpperCase() + categoryId.slice(1);
      const category = (SYSTEM_CATEGORIES.includes(categoryName as Category) ? categoryName : 'Work') as Category;

      // Convert status from 'in_progress' to 'in-progress'
      let status: 'scheduled' | 'in-progress' | 'done' | 'canceled' = 'scheduled';
      if (plan.status === 'in_progress') {
        status = 'in-progress';
      } else if (plan.status === 'done' || plan.status === 'canceled') {
        status = plan.status;
      }

      // Ensure dates are Date objects
      const startTime = plan.startTime instanceof Date ? plan.startTime : new Date(plan.startTime);
      const endTime = plan.endTime instanceof Date ? plan.endTime : new Date(plan.endTime);

      realBlocks.push({
        id: plan._id || plan.id || '',
        title: plan.taskTitle || 'Untitled',
        category,
        startTime,
        endTime,
        status,
        taskId: plan.taskId || null,
        isVirtual: false,
        planId: plan._id || plan.id || '',
        sessionId: plan.sessionId,
      });
    });

    const inProgressTasks = tasks.filter(t => t.status === 'in-progress');
    
    inProgressTasks.forEach(task => {
      const timePlanning = (task as any).timePlanning;
      if (!timePlanning?.enabled || !timePlanning.defaultStartTime) return;

      const [startHours, startMins] = timePlanning.defaultStartTime.split(':').map(Number);
      const [endHours, endMins] = timePlanning.defaultEndTime 
        ? timePlanning.defaultEndTime.split(':').map(Number)
        : [startHours + 1, startMins];

      const recurrence = timePlanning.recurrence?.type || 'none';
      const dayOfWeek = selectedDate.getDay();
      const shouldCreate = 
        recurrence === 'daily' ||
        (recurrence === 'weekdays' && dayOfWeek >= 1 && dayOfWeek <= 5) ||
        recurrence === 'none';

      if (!shouldCreate) return;

      const start = new Date(selectedDate);
      start.setHours(startHours, startMins, 0, 0);

      const end = new Date(selectedDate);
      end.setHours(endHours, endMins, 0, 0);

      const dateStr = normalizeDateToString(selectedDate);
      const excludedDates = timePlanning.excludedDates || [];
      if (excludedDates.includes(dateStr)) {
        return;
      }

      const override = findOverrideForTaskAndDate(task.id, selectedDate, realPlans, false);

      if (!override) {
        let category: Category = 'Work';
        
        if (task.category) {
          // Check if task.category matches any SYSTEM_CATEGORY (case-insensitive)
          const matchedCategory = SYSTEM_CATEGORIES.find(
            cat => cat.toLowerCase() === task.category?.toLowerCase()
          );
          category = (matchedCategory || 'Work') as Category;
        }

        virtualBlocks.push({
          id: `virtual-${task.id}-${dateStr}`,
          title: task.title,
          category,
          startTime: start,
          endTime: end,
          status: 'scheduled',
          taskId: task.id,
          isVirtual: true,
        });
      }
    });

    const allBlocks: PlannedBlock[] = [...realBlocks];
    
    virtualBlocks.forEach(virtual => {
      const hasRealPlan = realBlocks.some(real => 
        real.taskId === virtual.taskId && 
        real.startTime.getTime() === virtual.startTime.getTime()
      );
      if (!hasRealPlan) {
        allBlocks.push(virtual);
      }
    });

    return allBlocks.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
  }, [tasks, realPlans, selectedDate, dateStr]);

  const handleSlotClick = (hour: number) => {
    const startHours = String(hour).padStart(2, '0');
    const endHours = String(hour + 1).padStart(2, '0');

    setSelectedHour(hour);
    setNewBlock({
      title: '',
      startTime: `${startHours}:00`,
      endTime: `${endHours}:00`,
    });
    setIsDialogOpen(true);
  };

  const handleEditClick = (block: PlannedBlock) => {
    setEditingBlock(block);
    const startHours = String(block.startTime.getHours()).padStart(2, '0');
    const startMins = String(block.startTime.getMinutes()).padStart(2, '0');
    const endHours = String(block.endTime.getHours()).padStart(2, '0');
    const endMins = String(block.endTime.getMinutes()).padStart(2, '0');
    
    setNewBlock({
      title: block.title,
      startTime: `${startHours}:${startMins}`,
      endTime: `${endHours}:${endMins}`,
    });
    setIsEditDialogOpen(true);
  };

  const handleSaveBlock = async () => {
    if (!newBlock.title || !newBlock.startTime || !newBlock.endTime) return;

    const [startHours, startMinutes] = newBlock.startTime.split(':').map(Number);
    const [endHours, endMinutes] = newBlock.endTime.split(':').map(Number);

    const start = new Date(selectedDate);
    start.setHours(startHours, startMinutes, 0, 0);

    const end = new Date(selectedDate);
    end.setHours(endHours, endMinutes, 0, 0);

    if (end <= start) {
      toast.error('End time must be after start time');
      return;
    }

    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      const categoryId = await classifyTitleToCategoryId(newBlock.title);

      if (editingBlock) {
        if (editingBlock.isVirtual && editingBlock.taskId) {
          const instanceDate = new Date(selectedDate);
          instanceDate.setHours(0, 0, 0, 0);
          
          await createPlan({
            taskId: editingBlock.taskId,
            taskTitle: newBlock.title,
            categoryId,
            startTime: start.toISOString(),
            endTime: end.toISOString(),
            isOverride: true,
            instanceDate: selectedDate.toISOString().split('T')[0],
          } as any);
        } else if (editingBlock.planId) {
          await updatePlan(editingBlock.planId, {
            taskTitle: newBlock.title,
            categoryId,
            startTime: start.toISOString(),
            endTime: end.toISOString(),
          } as any);
        }
      } else {
        await createPlan({
          taskTitle: newBlock.title,
          categoryId,
          startTime: start.toISOString(),
          endTime: end.toISOString(),
        });
      }

      setIsDialogOpen(false);
      setIsEditDialogOpen(false);
      setEditingBlock(null);
      setNewBlock({ title: '', startTime: '', endTime: '' });
      
      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetchPlans(dateStr, tz);
      
      toast.success(editingBlock ? 'Plan updated' : 'Plan created');
    } catch (error) {
      console.error('Failed to save plan:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to save plan');
    }
  };

  const handleStartNow = async (block: PlannedBlock) => {
    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      if (activeSession) {
        await stopSession();
      }

      await startSession(block.taskId || null, block.title, block.category);

      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetchPlans(dateStr, tz);
      
      toast.success('Timer started');
    } catch (error) {
      console.error('Failed to start timer:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to start timer');
    }
  };

  const handleStopTimer = async (block: PlannedBlock) => {
    if (!isTimeApiReady() || !activeSession) {
      toast.error('No active session');
      return;
    }

    try {
      await stopSession();

      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetchPlans(dateStr, tz);
      
      toast.success('Timer stopped');
    } catch (error) {
      console.error('Failed to stop timer:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to stop timer');
    }
  };

  const handleDeleteBlock = async (block: PlannedBlock) => {
    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      if (block.planId) {
        await deletePlan(block.planId);
      }

      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetchPlans(dateStr, tz);
      
      toast.success('Plan deleted');
    } catch (error) {
      console.error('Failed to delete plan:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to delete plan');
    }
  };

  const handleMarkDone = async (block: PlannedBlock) => {
    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      // Convert Category to categoryId (lowercase)
      const categoryId = block.category.toLowerCase();

      // Create a session for this time block
      await sessionsApi.createSession({
        taskId: block.taskId || null,
        taskTitle: block.title,
        categoryId,
        startTime: block.startTime.toISOString(),
        endTime: block.endTime.toISOString(),
        notes: '',
      });

      // Update plan status to 'done' if it has a planId
      if (block.planId) {
        await updatePlan(block.planId, {
          status: 'done',
        } as any);
      }

      // Refresh plans and sessions
      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const isToday = selectedDate.toDateString() === new Date().toDateString();
      
      const { fetchSessions } = useSessionsStore.getState();
      await Promise.all([
        fetchPlans(dateStr, tz),
        fetchSessions(dateStr, tz),
        fetchSummary(dateStr, tz, isToday),
      ]);
      
      toast.success('Time block marked as done');
    } catch (error) {
      console.error('Failed to mark block as done:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to mark block as done');
    }
  };

  // Calculate block positions to handle overlaps
  const blockPositions = useMemo(() => {
    const positions = new Map<string, { width: number; left: number }>();
    
    // Helper function to check if two blocks overlap
    const doBlocksOverlap = (block1: PlannedBlock, block2: PlannedBlock): boolean => {
      const start1 = block1.startTime.getTime();
      const end1 = block1.endTime.getTime();
      const start2 = block2.startTime.getTime();
      const end2 = block2.endTime.getTime();
      
      return start1 < end2 && start2 < end1;
    };
    
    // For each block, find all overlapping blocks
    mergedBlocks.forEach((block, index) => {
      const overlappingBlocks: { block: PlannedBlock; index: number }[] = [];
      
      // Find all blocks that overlap with this one
      mergedBlocks.forEach((otherBlock, otherIndex) => {
        if (doBlocksOverlap(block, otherBlock)) {
          overlappingBlocks.push({ block: otherBlock, index: otherIndex });
        }
      });
      
      // Sort overlapping blocks by start time, then by index for consistent ordering
      overlappingBlocks.sort((a, b) => {
        const timeDiff = a.block.startTime.getTime() - b.block.startTime.getTime();
        if (timeDiff !== 0) return timeDiff;
        return a.index - b.index;
      });
      
      // Find this block's position in the overlap group
      const positionInGroup = overlappingBlocks.findIndex(
        item => item.block.id === block.id
      );
      
      // Calculate width and left position
      // Blocks will be displayed side-by-side with equal width and small gaps
      const overlapCount = overlappingBlocks.length;
      const gapPercent = 1; // Gap between blocks as percentage of container
      const totalGap = gapPercent * (overlapCount - 1);
      const availableWidth = 100 - totalGap;
      const width = availableWidth / overlapCount;
      const left = positionInGroup * (width + gapPercent);
      
      positions.set(block.id, { width, left });
    });
    
    return positions;
  }, [mergedBlocks]);

  const getBlockStyle = (block: PlannedBlock) => {
    const startHour = block.startTime.getHours();
    const startMinute = block.startTime.getMinutes();
    const endHour = block.endTime.getHours();
    const endMinute = block.endTime.getMinutes();

    const PIXELS_PER_HOUR = 80;
    const top = (startHour + startMinute / 60) * PIXELS_PER_HOUR;
    const duration = (endHour - startHour) + (endMinute - startMinute) / 60;
    const height = duration * PIXELS_PER_HOUR;

    const position = blockPositions.get(block.id) || { width: 100, left: 0 };

    return { 
      top: `${top}px`, 
      height: `${height}px`,
      width: `${position.width}%`,
      left: `${position.left}%`,
      zIndex: 1 
    };
  };

  return (
    <div className="bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-lg p-6 h-[600px] flex flex-col">
      <div className="flex items-center justify-between mb-4 flex-shrink-0">
        <div className="flex items-center gap-2">
          <Calendar className="w-5 h-5 text-neutral-600 dark:text-neutral-400" />
          <h2 className="text-neutral-900 dark:text-neutral-100 font-semibold">Planned Time Blocks</h2>
        </div>
      </div>
      
      <div className="flex-1 overflow-y-auto min-h-0 pr-2 scrollbar-thin scrollbar-thumb-neutral-300 dark:scrollbar-thumb-neutral-700 scrollbar-track-transparent dark:scrollbar-track-neutral-900">
        <div className="relative pl-16">
          {HOURS.map((hour) => (
            <div
              key={hour}
              className="h-[80px] border-t border-neutral-200 dark:border-neutral-800 relative"
            >
              <button
                type="button"
                onClick={() => handleSlotClick(hour)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleSlotClick(hour);
                  }
                }}
                className="absolute -left-16 top-0 w-14 h-full cursor-pointer hover:bg-neutral-100 dark:hover:bg-neutral-800/30 transition-colors flex items-start justify-end focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                aria-label={`Create time block at ${formatHour(hour)}`}
              >
                <span className="text-xs text-neutral-600 dark:text-neutral-400 -translate-y-1/2 bg-white dark:bg-neutral-900 px-1">
                  {formatHour(hour)}
                </span>
              </button>
            </div>
          ))}

          <div className="absolute inset-0 left-16 z-10 pointer-events-auto" role="grid" aria-label="Time slots for creating planned blocks">
            {HOURS.map((hour) => (
              <button
                key={`grid-${hour}`}
                type="button"
                onClick={() => handleSlotClick(hour)}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    handleSlotClick(hour);
                  }
                }}
                className="h-[80px] w-full cursor-pointer hover:bg-neutral-100 dark:hover:bg-neutral-800/20 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
                aria-label={`Create time block at ${formatHour(hour)}`}
              />
            ))}
          </div>

          <div className="absolute top-0 right-0 bottom-0 left-16 pointer-events-none z-30">
            {loading ? (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="text-neutral-500 dark:text-neutral-400">Loading...</div>
              </div>
            ) : (
              mergedBlocks.map((block) => {
                const hasActiveSession = activeSession && (
                  (block.taskId && activeSession.taskId === block.taskId)
                );
                
                return (
                  <PlannedBlockOverlay
                    key={block.id} 
                    block={block} 
                    style={getBlockStyle(block)}
                    hasActiveSession={!!hasActiveSession}
                    onEdit={() => handleEditClick(block)}
                    onStartNow={() => handleStartNow(block)}
                    onStopTimer={() => handleStopTimer(block)}
                    onDeleteBlock={() => handleDeleteBlock(block)}
                    onMarkDone={() => handleMarkDone(block)}
                  />
                );
              })
            )}
          </div>
        </div>
      </div>

      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent className="bg-white dark:bg-neutral-900 border-neutral-200 dark:border-neutral-800">
          <DialogHeader>
            <DialogTitle className="text-neutral-900 dark:text-neutral-100">Create Planned Block</DialogTitle>
            <DialogDescription className="text-neutral-600 dark:text-neutral-400">Add a new time block to your schedule.</DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div className="space-y-2">
              <Label className="text-neutral-900 dark:text-neutral-100">Title</Label>
              <Input
                type="text"
                placeholder="What will you work on?"
                value={newBlock.title}
                onChange={(e) => setNewBlock({ ...newBlock, title: e.target.value })}
                className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800"
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">Start Time</Label>
                <Input
                  type="time"
                  value={newBlock.startTime}
                  onChange={(e) => setNewBlock({ ...newBlock, startTime: e.target.value })}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">End Time</Label>
                <Input
                  type="time"
                  value={newBlock.endTime}
                  onChange={(e) => setNewBlock({ ...newBlock, endTime: e.target.value })}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>
            </div>

            <Button 
              onClick={handleSaveBlock}
              disabled={!newBlock.title || !newBlock.startTime || !newBlock.endTime}
              className="w-full bg-blue-600 dark:bg-indigo-700 hover:bg-blue-700 dark:hover:bg-indigo-800"
            >
              <Plus className="w-4 h-4 mr-2" />
              Create Block
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
        <DialogContent className="bg-white dark:bg-neutral-900 border-neutral-200 dark:border-neutral-800">
          <DialogHeader>
            <DialogTitle className="text-neutral-900 dark:text-neutral-100">Edit Planned Block</DialogTitle>
            <DialogDescription className="text-neutral-600 dark:text-neutral-400">Update the time block details.</DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div className="space-y-2">
              <Label className="text-neutral-900 dark:text-neutral-100">Title</Label>
              <Input
                type="text"
                placeholder="What will you work on?"
                value={newBlock.title}
                onChange={(e) => setNewBlock({ ...newBlock, title: e.target.value })}
                className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800"
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">Start Time</Label>
                <Input
                  type="time"
                  value={newBlock.startTime}
                  onChange={(e) => setNewBlock({ ...newBlock, startTime: e.target.value })}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">End Time</Label>
                <Input
                  type="time"
                  value={newBlock.endTime}
                  onChange={(e) => setNewBlock({ ...newBlock, endTime: e.target.value })}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>
            </div>

            <Button 
              onClick={handleSaveBlock}
              disabled={!newBlock.title || !newBlock.startTime || !newBlock.endTime}
              className="w-full bg-blue-600 dark:bg-indigo-700 hover:bg-blue-700 dark:hover:bg-indigo-800"
            >
              <Edit className="w-4 h-4 mr-2" />
              Update Block
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}

interface PlannedBlockOverlayProps {
  block: PlannedBlock;
  style: { top: string; height: string; width: string; left: string; zIndex: number };
  hasActiveSession: boolean;
  onEdit: () => void;
  onStartNow: () => void;
  onStopTimer: () => void;
  onDeleteBlock: () => void;
  onMarkDone: () => void;
}

function PlannedBlockOverlay({ block, style, hasActiveSession, onEdit, onStartNow, onStopTimer, onDeleteBlock, onMarkDone }: PlannedBlockOverlayProps) {
  const getCategoryColorClass = (category: Category) => {
    const colors: Record<Category, string> = {
      Work: 'bg-blue-500/20 dark:bg-blue-500/20 border-blue-500/50 dark:border-blue-500/50 text-blue-700 dark:text-blue-300',
      Personal: 'bg-green-500/20 dark:bg-green-500/20 border-green-500/50 dark:border-green-500/50 text-green-700 dark:text-green-300',
      Errands: 'bg-orange-500/20 dark:bg-orange-500/20 border-orange-500/50 dark:border-orange-500/50 text-orange-700 dark:text-orange-300',
      Design: 'bg-pink-500/20 dark:bg-pink-500/20 border-pink-500/50 dark:border-pink-500/50 text-pink-700 dark:text-pink-300',
      Engineering: 'bg-teal-500/20 dark:bg-teal-500/20 border-teal-500/50 dark:border-teal-500/50 text-teal-700 dark:text-teal-300',
      Marketing: 'bg-yellow-500/20 dark:bg-yellow-500/20 border-yellow-500/50 dark:border-yellow-500/50 text-yellow-700 dark:text-yellow-300',
      Finance: 'bg-indigo-500/20 dark:bg-indigo-500/20 border-indigo-500/50 dark:border-indigo-500/50 text-indigo-700 dark:text-indigo-300',
      Rest: 'bg-amber-500/20 dark:bg-amber-500/20 border-amber-500/50 dark:border-amber-500/50 text-amber-700 dark:text-amber-300',
      Health: 'bg-emerald-500/20 dark:bg-emerald-500/20 border-emerald-500/50 dark:border-emerald-500/50 text-emerald-700 dark:text-emerald-300',
      Learning: 'bg-purple-500/20 dark:bg-purple-500/20 border-purple-500/50 dark:border-purple-500/50 text-purple-700 dark:text-purple-300',
      Admin: 'bg-gray-500/20 dark:bg-gray-500/20 border-gray-500/50 dark:border-gray-500/50 text-gray-700 dark:text-gray-300',
      Other: 'bg-gray-500/20 dark:bg-gray-500/20 border-gray-500/50 dark:border-gray-500/50 text-gray-700 dark:text-gray-300',
    };
    return colors[category];
  };

  return (
    <div
      role="article"
      tabIndex={0}
      className={`absolute rounded-lg border-2 p-2 pointer-events-auto group ${getCategoryColorClass(block.category)} ${block.status === 'done' ? 'opacity-60' : ''}`}
      style={{ ...style, zIndex: (style.zIndex || 0) + 100 }}
      onClick={(e) => e.stopPropagation()}
      onKeyDown={(e) => {
        if (e.key === 'Enter' || e.key === ' ') {
          e.stopPropagation();
        }
      }}
      aria-label={`Time block: ${block.title} from ${formatTime(block.startTime)} to ${formatTime(block.endTime)}`}
    >
      <div className="flex items-start justify-between gap-2">
        <div className="flex-1 min-w-0">
          <div className="text-sm truncate">{block.title}</div>
          <div className="text-xs opacity-75 mt-0.5">
            {formatTime(block.startTime)} - {formatTime(block.endTime)}
          </div>
        </div>
        
        <div className="flex items-center gap-1 opacity-60 group-hover:opacity-100 transition-opacity">
          <button
            type="button"
            onClick={(e) => { e.stopPropagation(); onEdit(); }}
            className="p-1.5 rounded hover:bg-blue-600/30 transition-colors cursor-pointer"
            title="Edit block"
          >
            <Edit className="w-4 h-4" />
          </button>

          {block.status === 'done' ? null : (
            <>
              {hasActiveSession ? (
                <button
                  type="button"
                  onClick={(e) => { e.stopPropagation(); onStopTimer(); }}
                  className="p-1.5 rounded hover:bg-red-600/30 transition-colors cursor-pointer"
                  title="Stop timer"
                >
                  <Square className="w-4 h-4" />
                </button>
              ) : block.status === 'scheduled' && (
                <>
                  <button
                    type="button"
                    onClick={(e) => { e.stopPropagation(); onStartNow(); }}
                    className="p-1.5 rounded hover:bg-blue-600/30 transition-colors cursor-pointer"
                    title="Start timer"
                  >
                    <Play className="w-4 h-4" />
                  </button>
                  <button
                    type="button"
                    onClick={(e) => { e.stopPropagation(); onMarkDone(); }}
                    className="p-1.5 rounded hover:bg-green-600/30 transition-colors cursor-pointer"
                    title="Mark as done"
                  >
                    <Check className="w-4 h-4" />
                  </button>
                </>
              )}
              
              <button
                type="button"
                onClick={(e) => { e.stopPropagation(); onDeleteBlock(); }}
                className="p-1.5 rounded hover:bg-red-600/30 transition-colors cursor-pointer"
                title="Delete block"
              >
                <Trash2 className="w-4 h-4" />
              </button>
            </>
          )}
        </div>
      </div>
    </div>
  );
}

function formatHour(hour: number): string {
  if (hour === 0) return '12 AM';
  if (hour < 12) return `${hour} AM`;
  if (hour === 12) return '12 PM';
  return `${hour - 12} PM`;
}

