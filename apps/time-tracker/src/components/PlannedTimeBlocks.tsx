import { useState, useEffect, useMemo, useCallback, memo } from 'react';
import { PlannedBlock, Category } from '../types';
import { formatTime, formatDateStr, getTimezone, getCategoryBlockColor } from '../lib/utils';
import { classifyTitleToCategoryId } from '../lib/classification';
import { Button, Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, Input, Label } from '@efficio/ui';
import { Play, Calendar, Plus, Trash2, Square, Edit } from 'lucide-react';
import { isTimeApiReady, Plan } from '../services/timeApi';
import { useTasksStore } from '../store/slices/tasksSlice';
import { usePlansStore } from '../store/slices/plansSlice';
import { useSessionsStore } from '../store/slices/sessionsSlice';
import { toast } from 'sonner';

const HOURS = Array.from({ length: 24 }, (_, i) => i);
const PIXELS_PER_HOUR = 80;

// Move helper functions outside component to prevent recreation on every render
// Fixed: Don't mutate the input date
const normalizeDateToString = (date: Date | string): string => {
  const d = typeof date === 'string' ? new Date(date) : new Date(date.getTime());
  d.setHours(0, 0, 0, 0);
  return d.toISOString().split('T')[0];
};

const findOverrideForTaskAndDate = (
  taskId: string,
  targetDate: Date,
  plans: Plan[],
  includeCanceled: boolean = false
): Plan | undefined => {
  const targetDateStr = normalizeDateToString(targetDate);
  const searchTaskId = String(taskId);
  
  return plans.find(p => {
    if (!p.taskId || p.isAutoGenerated) return false;
    if (!includeCanceled && p.status === 'canceled') return false;
    if (includeCanceled && p.status !== 'canceled') return false;
    
    const pTaskId = typeof p.taskId === 'string' 
      ? p.taskId 
      : String(p.taskId);
    
    if (pTaskId !== searchTaskId) return false;
    
    if (p.instanceDate) {
      return normalizeDateToString(p.instanceDate) === targetDateStr;
    }
    
    return normalizeDateToString(p.startTime) === targetDateStr;
  });
};

const formatHour = (hour: number): string => {
  if (hour === 0) return '12 AM';
  if (hour < 12) return `${hour} AM`;
  if (hour === 12) return '12 PM';
  return `${hour - 12} PM`;
};


const CATEGORY_MAP: Record<string, Category> = {
  'Work': 'Work',
  'Personal': 'Personal',
  'Errands': 'Errands',
  'Design': 'Design',
  'Engineering': 'Engineering',
  'Marketing': 'Marketing',
  'Finance': 'Finance',
  'Rest': 'Rest',
  'Health': 'Health',
  'Learning': 'Learning',
  'Admin': 'Admin',
  'Other': 'Other',
};

// Helper to compute block style - pure function
const computeBlockStyle = (block: PlannedBlock): { top: string; height: string; width: string; left: string; zIndex: number } => {
  const startHour = block.startTime.getHours();
  const startMinute = block.startTime.getMinutes();
  const endHour = block.endTime.getHours();
  const endMinute = block.endTime.getMinutes();

  const top = (startHour + startMinute / 60) * PIXELS_PER_HOUR;
  const duration = (endHour - startHour) + (endMinute - startMinute) / 60;
  const height = duration * PIXELS_PER_HOUR;

  return { 
    top: `${top}px`, 
    height: `${height}px`,
    width: '100%',
    left: '0%',
    zIndex: 1 
  };
};

interface PlannedTimeBlocksProps {
  selectedDate: Date;
  getAccessToken?: () => Promise<string | undefined>;
}

export function PlannedTimeBlocks({ selectedDate }: PlannedTimeBlocksProps) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [editingBlock, setEditingBlock] = useState<PlannedBlock | null>(null);
  const [newBlock, setNewBlock] = useState({
    title: '',
    startTime: '',
    endTime: '',
  });

  // Zustand stores
  const tasks = useTasksStore(state => state.tasks);
  const { plans: realPlans, loading, fetchPlans, createPlan, updatePlan, deletePlan } = usePlansStore();
  const activeSession = useSessionsStore(state => state.activeSession);
  const startSession = useSessionsStore(state => state.startSession);
  const stopSession = useSessionsStore(state => state.stopSession);

  const dateStr = useMemo(() => formatDateStr(selectedDate), [selectedDate]);

  const tz = useMemo(() => getTimezone(), []);

  useEffect(() => {
    if (!isTimeApiReady()) return;
    fetchPlans(dateStr, tz);
  }, [dateStr, tz, fetchPlans]);

  const mergedBlocks = useMemo(() => {
    const virtualBlocks: PlannedBlock[] = [];
    const realBlocks: PlannedBlock[] = [];

    const inProgressTasks = tasks.filter(t => t.status === 'in-progress');
    
    for (const task of inProgressTasks) {
      const timePlanning = (task as any).timePlanning;
      if (!timePlanning?.enabled || !timePlanning.defaultStartTime) continue;

      const [startHours, startMins] = timePlanning.defaultStartTime.split(':').map(Number);
      const [endHours, endMins] = timePlanning.defaultEndTime 
        ? timePlanning.defaultEndTime.split(':').map(Number)
        : [startHours + 1, startMins];

      const recurrence = timePlanning.recurrence?.type || 'none';
      const dayOfWeek = selectedDate.getDay();
      const shouldCreate = 
        recurrence === 'daily' ||
        (recurrence === 'weekdays' && dayOfWeek >= 1 && dayOfWeek <= 5) ||
        recurrence === 'none';

      if (!shouldCreate) continue;

      const start = new Date(selectedDate);
      start.setHours(startHours, startMins, 0, 0);

      const end = new Date(selectedDate);
      end.setHours(endHours, endMins, 0, 0);

      const currentDateStr = normalizeDateToString(selectedDate);
      const excludedDates = timePlanning.excludedDates || [];
      if (excludedDates.includes(currentDateStr)) continue;

      const override = findOverrideForTaskAndDate(task.id, selectedDate, realPlans, false);

      if (!override) {
        const category: Category = (task.category && CATEGORY_MAP[task.category]) || 'Work';

        virtualBlocks.push({
          id: `virtual-${task.id}-${currentDateStr}`,
          title: task.title,
          category,
          startTime: start,
          endTime: end,
          status: 'scheduled',
          taskId: task.id,
          isVirtual: true,
        });
      }
    }

    const allBlocks: PlannedBlock[] = [...realBlocks];
    
    for (const virtual of virtualBlocks) {
      const hasRealPlan = realBlocks.some(real => 
        real.taskId === virtual.taskId && 
        real.startTime.getTime() === virtual.startTime.getTime()
      );
      if (!hasRealPlan) {
        allBlocks.push(virtual);
      }
    }

    return allBlocks.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
  }, [tasks, realPlans, selectedDate]);

  // Pre-compute block styles to avoid recalculation in render
  const blockStyles = useMemo(() => {
    const styles = new Map<string, { top: string; height: string; width: string; left: string; zIndex: number }>();
    for (const block of mergedBlocks) {
      styles.set(block.id, computeBlockStyle(block));
    }
    return styles;
  }, [mergedBlocks]);

  // Pre-compute which blocks have active sessions
  const activeSessionTaskId = activeSession?.taskId;

  // Memoized callback handlers
  const handleSlotClick = useCallback((hour: number) => {
    const startHours = String(hour).padStart(2, '0');
    const endHours = String(hour + 1).padStart(2, '0');

    setNewBlock({
      title: '',
      startTime: `${startHours}:00`,
      endTime: `${endHours}:00`,
    });
    setIsDialogOpen(true);
  }, []);

  const handleEditClick = useCallback((block: PlannedBlock) => {
    setEditingBlock(block);
    const startHours = String(block.startTime.getHours()).padStart(2, '0');
    const startMins = String(block.startTime.getMinutes()).padStart(2, '0');
    const endHours = String(block.endTime.getHours()).padStart(2, '0');
    const endMins = String(block.endTime.getMinutes()).padStart(2, '0');
    
    setNewBlock({
      title: block.title,
      startTime: `${startHours}:${startMins}`,
      endTime: `${endHours}:${endMins}`,
    });
    setIsEditDialogOpen(true);
  }, []);

  const refreshPlans = useCallback(async () => {
    await fetchPlans(dateStr, tz);
  }, [fetchPlans, dateStr, tz]);

  const handleSaveBlock = useCallback(async () => {
    if (!newBlock.title || !newBlock.startTime || !newBlock.endTime) return;

    const [startHours, startMinutes] = newBlock.startTime.split(':').map(Number);
    const [endHours, endMinutes] = newBlock.endTime.split(':').map(Number);

    const start = new Date(selectedDate);
    start.setHours(startHours, startMinutes, 0, 0);

    const end = new Date(selectedDate);
    end.setHours(endHours, endMinutes, 0, 0);

    if (end <= start) {
      toast.error('End time must be after start time');
      return;
    }

    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      const categoryId = await classifyTitleToCategoryId(newBlock.title);

      if (editingBlock) {
        if (editingBlock.isVirtual && editingBlock.taskId) {
          await createPlan({
            taskId: editingBlock.taskId,
            taskTitle: newBlock.title,
            categoryId,
            startTime: start.toISOString(),
            endTime: end.toISOString(),
            isOverride: true,
            instanceDate: selectedDate.toISOString().split('T')[0],
          } as any);
        } else if (editingBlock.planId) {
          await updatePlan(editingBlock.planId, {
            taskTitle: newBlock.title,
            categoryId,
            startTime: start.toISOString(),
            endTime: end.toISOString(),
          } as any);
        }
      } else {
        await createPlan({
          taskTitle: newBlock.title,
          categoryId,
          startTime: start.toISOString(),
          endTime: end.toISOString(),
        });
      }

      setIsDialogOpen(false);
      setIsEditDialogOpen(false);
      setEditingBlock(null);
      setNewBlock({ title: '', startTime: '', endTime: '' });
      
      await refreshPlans();
      toast.success(editingBlock ? 'Plan updated' : 'Plan created');
    } catch (error) {
      console.error('Failed to save plan:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to save plan');
    }
  }, [newBlock, selectedDate, editingBlock, createPlan, updatePlan, refreshPlans]);

  const handleStartNow = useCallback(async (block: PlannedBlock) => {
    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      if (activeSession) {
        await stopSession();
      }

      await startSession(block.taskId || null, block.title, block.category);
      await refreshPlans();
      toast.success('Timer started');
    } catch (error) {
      console.error('Failed to start timer:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to start timer');
    }
  }, [activeSession, stopSession, startSession, refreshPlans]);

  const handleStopTimer = useCallback(async () => {
    if (!isTimeApiReady() || !activeSession) {
      toast.error('No active session');
      return;
    }

    try {
      await stopSession();
      await refreshPlans();
      toast.success('Timer stopped');
    } catch (error) {
      console.error('Failed to stop timer:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to stop timer');
    }
  }, [activeSession, stopSession, refreshPlans]);

  const handleDeleteBlock = useCallback(async (block: PlannedBlock) => {
    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      if (block.planId) {
        await deletePlan(block.planId);
      }
      await refreshPlans();
      toast.success('Plan deleted');
    } catch (error) {
      console.error('Failed to delete plan:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to delete plan');
    }
  }, [deletePlan, refreshPlans]);

  const handleTitleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setNewBlock(prev => ({ ...prev, title: e.target.value }));
  }, []);

  const handleStartTimeChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setNewBlock(prev => ({ ...prev, startTime: e.target.value }));
  }, []);

  const handleEndTimeChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setNewBlock(prev => ({ ...prev, endTime: e.target.value }));
  }, []);

  return (
    <div className="bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-lg p-6 h-[600px] flex flex-col">
      <div className="flex items-center justify-between mb-4 flex-shrink-0">
        <div className="flex items-center gap-2">
          <Calendar className="w-5 h-5 text-neutral-600 dark:text-neutral-400" />
          <h2 className="text-neutral-900 dark:text-neutral-100 font-semibold">Planned Time Blocks</h2>
        </div>
      </div>
      
      <div className="flex-1 overflow-y-auto min-h-0 pr-2 scrollbar-thin scrollbar-thumb-neutral-300 dark:scrollbar-thumb-neutral-700 scrollbar-track-transparent dark:scrollbar-track-neutral-900">
        <div className="relative pl-16">
          {HOURS.map((hour) => (
            <HourRow key={hour} hour={hour} onSlotClick={handleSlotClick} />
          ))}

          <div className="absolute inset-0 left-16 z-10 pointer-events-auto">
            {HOURS.map((hour) => (
              <HourSlot key={`grid-${hour}`} hour={hour} onSlotClick={handleSlotClick} />
            ))}
          </div>

          <div className="absolute top-0 right-0 bottom-0 left-16 pointer-events-none z-30">
            {loading ? (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="text-neutral-500 dark:text-neutral-400">Loading...</div>
              </div>
            ) : (
              mergedBlocks.map((block) => (
                <PlannedBlockOverlay
                  key={block.id} 
                  block={block} 
                  style={blockStyles.get(block.id)!}
                  hasActiveSession={!!(block.taskId && activeSessionTaskId === block.taskId)}
                  onEdit={handleEditClick}
                  onStartNow={handleStartNow}
                  onStopTimer={handleStopTimer}
                  onDeleteBlock={handleDeleteBlock}
                />
              ))
            )}
          </div>
        </div>
      </div>

      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent className="bg-white dark:bg-neutral-900 border-neutral-200 dark:border-neutral-800">
          <DialogHeader>
            <DialogTitle className="text-neutral-900 dark:text-neutral-100">Create Planned Block</DialogTitle>
            <DialogDescription className="text-neutral-600 dark:text-neutral-400">Add a new time block to your schedule.</DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div className="space-y-2">
              <Label className="text-neutral-900 dark:text-neutral-100">Title</Label>
              <Input
                type="text"
                placeholder="What will you work on?"
                value={newBlock.title}
                onChange={handleTitleChange}
                className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800"
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">Start Time</Label>
                <Input
                  type="time"
                  value={newBlock.startTime}
                  onChange={handleStartTimeChange}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">End Time</Label>
                <Input
                  type="time"
                  value={newBlock.endTime}
                  onChange={handleEndTimeChange}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>
            </div>

            <Button 
              onClick={handleSaveBlock}
              disabled={!newBlock.title || !newBlock.startTime || !newBlock.endTime}
              className="w-full bg-blue-600 dark:bg-indigo-700 hover:bg-blue-700 dark:hover:bg-indigo-800"
            >
              <Plus className="w-4 h-4 mr-2" />
              Create Block
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
        <DialogContent className="bg-white dark:bg-neutral-900 border-neutral-200 dark:border-neutral-800">
          <DialogHeader>
            <DialogTitle className="text-neutral-900 dark:text-neutral-100">Edit Planned Block</DialogTitle>
            <DialogDescription className="text-neutral-600 dark:text-neutral-400">Update the time block details.</DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div className="space-y-2">
              <Label className="text-neutral-900 dark:text-neutral-100">Title</Label>
              <Input
                type="text"
                placeholder="What will you work on?"
                value={newBlock.title}
                onChange={handleTitleChange}
                className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800"
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">Start Time</Label>
                <Input
                  type="time"
                  value={newBlock.startTime}
                  onChange={handleStartTimeChange}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">End Time</Label>
                <Input
                  type="time"
                  value={newBlock.endTime}
                  onChange={handleEndTimeChange}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>
            </div>

            <Button 
              onClick={handleSaveBlock}
              disabled={!newBlock.title || !newBlock.startTime || !newBlock.endTime}
              className="w-full bg-blue-600 dark:bg-indigo-700 hover:bg-blue-700 dark:hover:bg-indigo-800"
            >
              <Edit className="w-4 h-4 mr-2" />
              Update Block
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}

// Memoized sub-components to prevent unnecessary re-renders
interface HourRowProps {
  hour: number;
  onSlotClick: (hour: number) => void;
}

const HourRow = memo(function HourRow({ hour, onSlotClick }: HourRowProps) {
  const handleClick = useCallback(() => onSlotClick(hour), [hour, onSlotClick]);
  
  return (
    <div className="h-[80px] border-t border-neutral-200 dark:border-neutral-800 relative">
      <div 
        onClick={handleClick}
        className="absolute -left-16 top-0 w-14 h-full cursor-pointer hover:bg-neutral-100 dark:hover:bg-neutral-800/30 transition-colors flex items-start justify-end"
      >
        <span className="text-xs text-neutral-600 dark:text-neutral-400 -translate-y-1/2 bg-white dark:bg-neutral-900 px-1">
          {formatHour(hour)}
        </span>
      </div>
    </div>
  );
});

interface HourSlotProps {
  hour: number;
  onSlotClick: (hour: number) => void;
}

const HourSlot = memo(function HourSlot({ hour, onSlotClick }: HourSlotProps) {
  const handleClick = useCallback(() => onSlotClick(hour), [hour, onSlotClick]);
  
  return (
    <div
      onClick={handleClick}
      className="h-[80px] cursor-pointer hover:bg-neutral-100 dark:hover:bg-neutral-800/20 transition-colors"
    />
  );
});

interface PlannedBlockOverlayProps {
  block: PlannedBlock;
  style: { top: string; height: string; width: string; left: string; zIndex: number };
  hasActiveSession: boolean;
  onEdit: (block: PlannedBlock) => void;
  onStartNow: (block: PlannedBlock) => void;
  onStopTimer: () => void;
  onDeleteBlock: (block: PlannedBlock) => void;
}

const PlannedBlockOverlay = memo(function PlannedBlockOverlay({ 
  block, 
  style, 
  hasActiveSession, 
  onEdit, 
  onStartNow, 
  onStopTimer, 
  onDeleteBlock 
}: PlannedBlockOverlayProps) {
  const handleEdit = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onEdit(block);
  }, [block, onEdit]);

  const handleStartNow = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onStartNow(block);
  }, [block, onStartNow]);

  const handleStopTimer = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onStopTimer();
  }, [onStopTimer]);

  const handleDelete = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
    onDeleteBlock(block);
  }, [block, onDeleteBlock]);

  const handleContainerClick = useCallback((e: React.MouseEvent) => {
    e.stopPropagation();
  }, []);

  // Memoize the combined style to prevent object recreation
  const combinedStyle = useMemo(() => ({
    ...style,
    zIndex: (style.zIndex || 0) + 100
  }), [style]);

  return (
    <div
      className={`absolute rounded-lg border-2 p-2 pointer-events-auto group ${getCategoryBlockColor(block.category)}`}
      style={combinedStyle}
      onClick={handleContainerClick}
    >
      <div className="flex items-start justify-between gap-2">
        <div className="flex-1 min-w-0">
          <div className="text-sm truncate">{block.title}</div>
          <div className="text-xs opacity-75 mt-0.5">
            {formatTime(block.startTime)} - {formatTime(block.endTime)}
          </div>
        </div>
        
        <div className="flex items-center gap-1 opacity-60 group-hover:opacity-100 transition-opacity">
          <button
            type="button"
            onClick={handleEdit}
            className="p-1.5 rounded hover:bg-blue-600/30 transition-colors cursor-pointer"
            title="Edit block"
          >
            <Edit className="w-4 h-4" />
          </button>

          {hasActiveSession ? (
            <button
              type="button"
              onClick={handleStopTimer}
              className="p-1.5 rounded hover:bg-red-600/30 transition-colors cursor-pointer"
              title="Stop timer"
            >
              <Square className="w-4 h-4" />
            </button>
          ) : block.status === 'scheduled' && (
            <button
              type="button"
              onClick={handleStartNow}
              className="p-1.5 rounded hover:bg-blue-600/30 transition-colors cursor-pointer"
              title="Start timer"
            >
              <Play className="w-4 h-4" />
            </button>
          )}
          
          <button
            type="button"
            onClick={handleDelete}
            className="p-1.5 rounded hover:bg-red-600/30 transition-colors cursor-pointer"
            title="Delete block"
          >
            <Trash2 className="w-4 h-4" />
          </button>
        </div>
      </div>
    </div>
  );
});
