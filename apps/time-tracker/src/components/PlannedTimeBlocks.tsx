import { useState, useEffect, useMemo } from 'react';
import { PlannedBlock, Category } from '../types';
import { formatTime, getCategoryColor } from '../lib/utils';
import { classifyTitleToCategoryId } from '../lib/classification';
import { Button, Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, Input, Label } from '@efficio/ui';
import { Play, Check, Calendar, Plus, Trash2, Square, Edit } from 'lucide-react';
import { plansApi, sessionsApi, isTimeApiReady, Plan } from '../services/timeApi';
import { useTasksStore } from '../store/slices/tasksSlice';
import { usePlansStore } from '../store/slices/plansSlice';
import { useSessionsStore } from '../store/slices/sessionsSlice';
import { useSummaryStore } from '../store/slices/summarySlice';
import { toast } from 'sonner';

const HOURS = Array.from({ length: 24 }, (_, i) => i);

interface PlannedTimeBlocksProps {
  selectedDate: Date;
  getAccessToken?: () => Promise<string | undefined>;
}

export function PlannedTimeBlocks({ selectedDate, getAccessToken }: PlannedTimeBlocksProps) {
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = useState(false);
  const [editingBlock, setEditingBlock] = useState<PlannedBlock | null>(null);
  const [selectedHour, setSelectedHour] = useState<number | null>(null);
  const [newBlock, setNewBlock] = useState({
    title: '',
    startTime: '',
    endTime: '',
  });

  // Zustand stores
  const { tasks } = useTasksStore();
  const { plans: realPlans, loading, fetchPlans, createPlan, updatePlan, deletePlan } = usePlansStore();
  const { activeSession, startSession, stopSession, fetchActiveSession } = useSessionsStore();
  const { fetchSummary } = useSummaryStore();

  const dateStr = useMemo(() => {
    const year = selectedDate.getFullYear();
    const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
    const day = String(selectedDate.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  }, [selectedDate]);

  const normalizeDateToString = (date: Date | string): string => {
    const d = typeof date === 'string' ? new Date(date) : date;
    d.setHours(0, 0, 0, 0);
    return d.toISOString().split('T')[0];
  };

  const findOverrideForTaskAndDate = (
    taskId: string,
    targetDate: Date,
    plans: Plan[],
    includeCanceled: boolean = false
  ): Plan | undefined => {
    const targetDateStr = normalizeDateToString(targetDate);
    const searchTaskId = String(taskId);
    
    return plans.find(p => {
      if (!p.taskId || p.isAutoGenerated) return false;
      if (!includeCanceled && p.status === 'canceled') return false;
      if (includeCanceled && p.status !== 'canceled') return false;
      
      let pTaskId: string;
      if (typeof p.taskId === 'string') {
        pTaskId = p.taskId;
      } else if (p.taskId && typeof (p.taskId as any).toString === 'function') {
        pTaskId = (p.taskId as any).toString();
      } else {
        pTaskId = String(p.taskId);
      }
      
      if (pTaskId !== searchTaskId) return false;
      
      if (p.instanceDate) {
        const pDateStr = normalizeDateToString(p.instanceDate);
        return pDateStr === targetDateStr;
      }
      
      const pStartDateStr = normalizeDateToString(p.startTime);
      return pStartDateStr === targetDateStr;
    });
  };

  useEffect(() => {
    if (!isTimeApiReady()) return;
    
    const year = selectedDate.getFullYear();
    const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
    const day = String(selectedDate.getDate()).padStart(2, '0');
    const dateStr = `${year}-${month}-${day}`;
    const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    
    fetchPlans(dateStr, tz);
  }, [selectedDate, fetchPlans]);

  const mergedBlocks = useMemo(() => {
    const virtualBlocks: PlannedBlock[] = [];
    const realBlocks: PlannedBlock[] = [];

    const inProgressTasks = tasks.filter(t => t.status === 'in-progress');
    
    inProgressTasks.forEach(task => {
      const timePlanning = (task as any).timePlanning;
      if (!timePlanning?.enabled || !timePlanning.defaultStartTime) return;

      const [startHours, startMins] = timePlanning.defaultStartTime.split(':').map(Number);
      const [endHours, endMins] = timePlanning.defaultEndTime 
        ? timePlanning.defaultEndTime.split(':').map(Number)
        : [startHours + 1, startMins];

      const recurrence = timePlanning.recurrence?.type || 'none';
      const dayOfWeek = selectedDate.getDay();
      const shouldCreate = 
        recurrence === 'daily' ||
        (recurrence === 'weekdays' && dayOfWeek >= 1 && dayOfWeek <= 5) ||
        recurrence === 'none';

      if (!shouldCreate) return;

      const start = new Date(selectedDate);
      start.setHours(startHours, startMins, 0, 0);

      const end = new Date(selectedDate);
      end.setHours(endHours, endMins, 0, 0);

      const dateStr = normalizeDateToString(selectedDate);
      const excludedDates = timePlanning.excludedDates || [];
      if (excludedDates.includes(dateStr)) {
        return;
      }

      const override = findOverrideForTaskAndDate(task.id, selectedDate, realPlans, false);

      if (!override) {
        let category: Category = 'Work';
        
        if (task.category) {
          const categoryMap: Record<string, Category> = {
            'Work': 'Work',
            'Personal': 'Personal',
            'Errands': 'Errands',
            'Design': 'Design',
            'Engineering': 'Engineering',
            'Marketing': 'Marketing',
            'Finance': 'Finance',
            'Rest': 'Rest',
            'Health': 'Health',
            'Learning': 'Learning',
            'Admin': 'Admin',
            'Other': 'Other',
          };
          category = categoryMap[task.category] || 'Work';
        }

        virtualBlocks.push({
          id: `virtual-${task.id}-${dateStr}`,
          title: task.title,
          category,
          startTime: start,
          endTime: end,
          status: 'scheduled',
          taskId: task.id,
          isVirtual: true,
        });
      }
    });

    const allBlocks: PlannedBlock[] = [...realBlocks];
    
    virtualBlocks.forEach(virtual => {
      const hasRealPlan = realBlocks.some(real => 
        real.taskId === virtual.taskId && 
        real.startTime.getTime() === virtual.startTime.getTime()
      );
      if (!hasRealPlan) {
        allBlocks.push(virtual);
      }
    });

    return allBlocks.sort((a, b) => a.startTime.getTime() - b.startTime.getTime());
  }, [tasks, realPlans, selectedDate, dateStr]);

  const handleSlotClick = (hour: number) => {
    const startHours = String(hour).padStart(2, '0');
    const endHours = String(hour + 1).padStart(2, '0');

    setSelectedHour(hour);
    setNewBlock({
      title: '',
      startTime: `${startHours}:00`,
      endTime: `${endHours}:00`,
    });
    setIsDialogOpen(true);
  };

  const handleEditClick = (block: PlannedBlock) => {
    setEditingBlock(block);
    const startHours = String(block.startTime.getHours()).padStart(2, '0');
    const startMins = String(block.startTime.getMinutes()).padStart(2, '0');
    const endHours = String(block.endTime.getHours()).padStart(2, '0');
    const endMins = String(block.endTime.getMinutes()).padStart(2, '0');
    
    setNewBlock({
      title: block.title,
      startTime: `${startHours}:${startMins}`,
      endTime: `${endHours}:${endMins}`,
    });
    setIsEditDialogOpen(true);
  };

  const handleSaveBlock = async () => {
    if (!newBlock.title || !newBlock.startTime || !newBlock.endTime) return;

    const [startHours, startMinutes] = newBlock.startTime.split(':').map(Number);
    const [endHours, endMinutes] = newBlock.endTime.split(':').map(Number);

    const start = new Date(selectedDate);
    start.setHours(startHours, startMinutes, 0, 0);

    const end = new Date(selectedDate);
    end.setHours(endHours, endMinutes, 0, 0);

    if (end <= start) {
      toast.error('End time must be after start time');
      return;
    }

    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      const categoryId = await classifyTitleToCategoryId(newBlock.title);

      if (editingBlock) {
        if (editingBlock.isVirtual && editingBlock.taskId) {
          const instanceDate = new Date(selectedDate);
          instanceDate.setHours(0, 0, 0, 0);
          
          await createPlan({
            taskId: editingBlock.taskId,
            taskTitle: newBlock.title,
            categoryId,
            startTime: start.toISOString(),
            endTime: end.toISOString(),
            isOverride: true,
            instanceDate: selectedDate.toISOString().split('T')[0],
          } as any);
        } else if (editingBlock.planId) {
          await updatePlan(editingBlock.planId, {
            taskTitle: newBlock.title,
            categoryId,
            startTime: start.toISOString(),
            endTime: end.toISOString(),
          } as any);
        }
      } else {
        await createPlan({
          taskTitle: newBlock.title,
          categoryId,
          startTime: start.toISOString(),
          endTime: end.toISOString(),
        });
      }

      setIsDialogOpen(false);
      setIsEditDialogOpen(false);
      setEditingBlock(null);
      setNewBlock({ title: '', startTime: '', endTime: '' });
      
      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetchPlans(dateStr, tz);
      
      toast.success(editingBlock ? 'Plan updated' : 'Plan created');
    } catch (error) {
      console.error('Failed to save plan:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to save plan');
    }
  };

  const handleStartNow = async (block: PlannedBlock) => {
    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      if (activeSession) {
        await stopSession();
      }

      await startSession(block.taskId || null, block.title, block.category);

      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetchPlans(dateStr, tz);
      
      toast.success('Timer started');
    } catch (error) {
      console.error('Failed to start timer:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to start timer');
    }
  };

  const handleStopTimer = async (block: PlannedBlock) => {
    if (!isTimeApiReady() || !activeSession) {
      toast.error('No active session');
      return;
    }

    try {
      await stopSession();

      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetchPlans(dateStr, tz);
      
      toast.success('Timer stopped');
    } catch (error) {
      console.error('Failed to stop timer:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to stop timer');
    }
  };

  const handleDeleteBlock = async (block: PlannedBlock) => {
    if (!isTimeApiReady()) {
      toast.error('API not initialized');
      return;
    }

    try {
      if (block.planId) {
        await deletePlan(block.planId);
      }

      const year = selectedDate.getFullYear();
      const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
      const day = String(selectedDate.getDate()).padStart(2, '0');
      const dateStr = `${year}-${month}-${day}`;
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      
      await fetchPlans(dateStr, tz);
      
      toast.success('Plan deleted');
    } catch (error) {
      console.error('Failed to delete plan:', error);
      toast.error(error instanceof Error ? error.message : 'Failed to delete plan');
    }
  };

  const getBlockStyle = (block: PlannedBlock) => {
    const startHour = block.startTime.getHours();
    const startMinute = block.startTime.getMinutes();
    const endHour = block.endTime.getHours();
    const endMinute = block.endTime.getMinutes();

    const PIXELS_PER_HOUR = 80;
    const top = (startHour + startMinute / 60) * PIXELS_PER_HOUR;
    const duration = (endHour - startHour) + (endMinute - startMinute) / 60;
    const height = duration * PIXELS_PER_HOUR;

    return { 
      top: `${top}px`, 
      height: `${height}px`,
      width: '100%',
      left: '0%',
      zIndex: 1 
    };
  };

  return (
    <div className="bg-white dark:bg-neutral-900 border border-neutral-200 dark:border-neutral-800 rounded-lg p-6 h-[600px] flex flex-col">
      <div className="flex items-center justify-between mb-4 flex-shrink-0">
        <div className="flex items-center gap-2">
          <Calendar className="w-5 h-5 text-neutral-600 dark:text-neutral-400" />
          <h2 className="text-neutral-900 dark:text-neutral-100 font-semibold">Planned Time Blocks</h2>
        </div>
      </div>
      
      <div className="flex-1 overflow-y-auto min-h-0 pr-2 scrollbar-thin scrollbar-thumb-neutral-300 dark:scrollbar-thumb-neutral-700 scrollbar-track-transparent dark:scrollbar-track-neutral-900">
        <div className="relative pl-16">
          {HOURS.map((hour) => (
            <div
              key={hour}
              className="h-[80px] border-t border-neutral-200 dark:border-neutral-800 relative"
            >
              <div 
                onClick={() => handleSlotClick(hour)}
                className="absolute -left-16 top-0 w-14 h-full cursor-pointer hover:bg-neutral-100 dark:hover:bg-neutral-800/30 transition-colors flex items-start justify-end"
              >
                <span className="text-xs text-neutral-600 dark:text-neutral-400 -translate-y-1/2 bg-white dark:bg-neutral-900 px-1">
                  {formatHour(hour)}
                </span>
              </div>
            </div>
          ))}

          <div className="absolute inset-0 left-16 z-10 pointer-events-auto">
            {HOURS.map((hour) => (
              <div
                key={`grid-${hour}`}
                onClick={() => handleSlotClick(hour)}
                className="h-[80px] cursor-pointer hover:bg-neutral-100 dark:hover:bg-neutral-800/20 transition-colors"
              />
            ))}
          </div>

          <div className="absolute top-0 right-0 bottom-0 left-16 pointer-events-none z-30">
            {loading ? (
              <div className="absolute inset-0 flex items-center justify-center">
                <div className="text-neutral-500 dark:text-neutral-400">Loading...</div>
              </div>
            ) : (
              mergedBlocks.map((block) => {
                const hasActiveSession = activeSession && (
                  (block.taskId && activeSession.taskId === block.taskId)
                );
                
                return (
                  <PlannedBlockOverlay
                    key={block.id} 
                    block={block} 
                    style={getBlockStyle(block)}
                    hasActiveSession={!!hasActiveSession}
                    onEdit={() => handleEditClick(block)}
                    onStartNow={() => handleStartNow(block)}
                    onStopTimer={() => handleStopTimer(block)}
                    onDeleteBlock={() => handleDeleteBlock(block)}
                  />
                );
              })
            )}
          </div>
        </div>
      </div>

      <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
        <DialogContent className="bg-white dark:bg-neutral-900 border-neutral-200 dark:border-neutral-800">
          <DialogHeader>
            <DialogTitle className="text-neutral-900 dark:text-neutral-100">Create Planned Block</DialogTitle>
            <DialogDescription className="text-neutral-600 dark:text-neutral-400">Add a new time block to your schedule.</DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div className="space-y-2">
              <Label className="text-neutral-900 dark:text-neutral-100">Title</Label>
              <Input
                type="text"
                placeholder="What will you work on?"
                value={newBlock.title}
                onChange={(e) => setNewBlock({ ...newBlock, title: e.target.value })}
                className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800"
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">Start Time</Label>
                <Input
                  type="time"
                  value={newBlock.startTime}
                  onChange={(e) => setNewBlock({ ...newBlock, startTime: e.target.value })}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">End Time</Label>
                <Input
                  type="time"
                  value={newBlock.endTime}
                  onChange={(e) => setNewBlock({ ...newBlock, endTime: e.target.value })}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>
            </div>

            <Button 
              onClick={handleSaveBlock}
              disabled={!newBlock.title || !newBlock.startTime || !newBlock.endTime}
              className="w-full bg-blue-600 dark:bg-indigo-700 hover:bg-blue-700 dark:hover:bg-indigo-800"
            >
              <Plus className="w-4 h-4 mr-2" />
              Create Block
            </Button>
          </div>
        </DialogContent>
      </Dialog>

      <Dialog open={isEditDialogOpen} onOpenChange={setIsEditDialogOpen}>
        <DialogContent className="bg-white dark:bg-neutral-900 border-neutral-200 dark:border-neutral-800">
          <DialogHeader>
            <DialogTitle className="text-neutral-900 dark:text-neutral-100">Edit Planned Block</DialogTitle>
            <DialogDescription className="text-neutral-600 dark:text-neutral-400">Update the time block details.</DialogDescription>
          </DialogHeader>
          
          <div className="space-y-4">
            <div className="space-y-2">
              <Label className="text-neutral-900 dark:text-neutral-100">Title</Label>
              <Input
                type="text"
                placeholder="What will you work on?"
                value={newBlock.title}
                onChange={(e) => setNewBlock({ ...newBlock, title: e.target.value })}
                className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800"
              />
            </div>

            <div className="grid grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">Start Time</Label>
                <Input
                  type="time"
                  value={newBlock.startTime}
                  onChange={(e) => setNewBlock({ ...newBlock, startTime: e.target.value })}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>

              <div className="space-y-2">
                <Label className="text-neutral-900 dark:text-neutral-100">End Time</Label>
                <Input
                  type="time"
                  value={newBlock.endTime}
                  onChange={(e) => setNewBlock({ ...newBlock, endTime: e.target.value })}
                  className="bg-white dark:bg-neutral-950 border-neutral-200 dark:border-neutral-800 text-neutral-900 dark:text-neutral-100"
                />
              </div>
            </div>

            <Button 
              onClick={handleSaveBlock}
              disabled={!newBlock.title || !newBlock.startTime || !newBlock.endTime}
              className="w-full bg-blue-600 dark:bg-indigo-700 hover:bg-blue-700 dark:hover:bg-indigo-800"
            >
              <Edit className="w-4 h-4 mr-2" />
              Update Block
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    </div>
  );
}

interface PlannedBlockOverlayProps {
  block: PlannedBlock;
  style: { top: string; height: string; width: string; left: string; zIndex: number };
  hasActiveSession: boolean;
  onEdit: () => void;
  onStartNow: () => void;
  onStopTimer: () => void;
  onDeleteBlock: () => void;
}

function PlannedBlockOverlay({ block, style, hasActiveSession, onEdit, onStartNow, onStopTimer, onDeleteBlock }: PlannedBlockOverlayProps) {
  const getCategoryColorClass = (category: Category) => {
    const colors: Record<Category, string> = {
      Work: 'bg-blue-500/20 dark:bg-blue-500/20 border-blue-500/50 dark:border-blue-500/50 text-blue-700 dark:text-blue-300',
      Personal: 'bg-green-500/20 dark:bg-green-500/20 border-green-500/50 dark:border-green-500/50 text-green-700 dark:text-green-300',
      Errands: 'bg-orange-500/20 dark:bg-orange-500/20 border-orange-500/50 dark:border-orange-500/50 text-orange-700 dark:text-orange-300',
      Design: 'bg-pink-500/20 dark:bg-pink-500/20 border-pink-500/50 dark:border-pink-500/50 text-pink-700 dark:text-pink-300',
      Engineering: 'bg-teal-500/20 dark:bg-teal-500/20 border-teal-500/50 dark:border-teal-500/50 text-teal-700 dark:text-teal-300',
      Marketing: 'bg-yellow-500/20 dark:bg-yellow-500/20 border-yellow-500/50 dark:border-yellow-500/50 text-yellow-700 dark:text-yellow-300',
      Finance: 'bg-indigo-500/20 dark:bg-indigo-500/20 border-indigo-500/50 dark:border-indigo-500/50 text-indigo-700 dark:text-indigo-300',
      Rest: 'bg-amber-500/20 dark:bg-amber-500/20 border-amber-500/50 dark:border-amber-500/50 text-amber-700 dark:text-amber-300',
      Health: 'bg-emerald-500/20 dark:bg-emerald-500/20 border-emerald-500/50 dark:border-emerald-500/50 text-emerald-700 dark:text-emerald-300',
      Learning: 'bg-purple-500/20 dark:bg-purple-500/20 border-purple-500/50 dark:border-purple-500/50 text-purple-700 dark:text-purple-300',
      Admin: 'bg-gray-500/20 dark:bg-gray-500/20 border-gray-500/50 dark:border-gray-500/50 text-gray-700 dark:text-gray-300',
      Other: 'bg-gray-500/20 dark:bg-gray-500/20 border-gray-500/50 dark:border-gray-500/50 text-gray-700 dark:text-gray-300',
    };
    return colors[category];
  };

  return (
    <div
      className={`absolute rounded-lg border-2 p-2 pointer-events-auto group ${getCategoryColorClass(block.category)}`}
      style={{ ...style, zIndex: (style.zIndex || 0) + 100 }}
      onClick={(e) => e.stopPropagation()}
    >
      <div className="flex items-start justify-between gap-2">
        <div className="flex-1 min-w-0">
          <div className="text-sm truncate">{block.title}</div>
          <div className="text-xs opacity-75 mt-0.5">
            {formatTime(block.startTime)} - {formatTime(block.endTime)}
          </div>
        </div>
        
        <div className="flex items-center gap-1 opacity-60 group-hover:opacity-100 transition-opacity">
          <button
            type="button"
            onClick={(e) => { e.stopPropagation(); onEdit(); }}
            className="p-1.5 rounded hover:bg-blue-600/30 transition-colors cursor-pointer"
            title="Edit block"
          >
            <Edit className="w-4 h-4" />
          </button>

          {hasActiveSession ? (
            <button
              type="button"
              onClick={(e) => { e.stopPropagation(); onStopTimer(); }}
              className="p-1.5 rounded hover:bg-red-600/30 transition-colors cursor-pointer"
              title="Stop timer"
            >
              <Square className="w-4 h-4" />
            </button>
          ) : block.status === 'scheduled' && (
            <button
              type="button"
              onClick={(e) => { e.stopPropagation(); onStartNow(); }}
              className="p-1.5 rounded hover:bg-blue-600/30 transition-colors cursor-pointer"
              title="Start timer"
            >
              <Play className="w-4 h-4" />
            </button>
          )}
          
          <button
            type="button"
            onClick={(e) => { e.stopPropagation(); onDeleteBlock(); }}
            className="p-1.5 rounded hover:bg-red-600/30 transition-colors cursor-pointer"
            title="Delete block"
          >
            <Trash2 className="w-4 h-4" />
          </button>
        </div>
      </div>
    </div>
  );
}

function formatHour(hour: number): string {
  if (hour === 0) return '12 AM';
  if (hour < 12) return `${hour} AM`;
  if (hour === 12) return '12 PM';
  return `${hour - 12} PM`;
}

